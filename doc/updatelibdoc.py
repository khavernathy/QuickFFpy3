#!/usr/bin/env python
# -*- coding: utf-8 -*-
# QuickFF is a code to quickly derive accurate force fields from ab initio input.
# Copyright (C) 2012 - 2015 Louis Vanduyfhuys <Louis.Vanduyfhuys@UGent.be>
# Steven Vandenbrande <Steven.Vandenbrande@UGent.be>,
# Toon Verstraelen <Toon.Verstraelen@UGent.be>, Center for Molecular Modeling
# (CMM), Ghent University, Ghent, Belgium; all rights reserved unless otherwise
# stated.
#
# This file is part of QuickFF.
#
# QuickFF is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# QuickFF is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>
#
#--


import importlib, os
from glob import glob
from io import StringIO

from common import write_if_changed


def discover():
    # find packages
    packages = {'quickff': []}
    for fn in glob('../quickff/*/__init__.py'):
        subpackage = fn.split('/')[2]
        if subpackage == 'tests':
            continue
        packages['quickff.%s' % subpackage] = []
    # find modules
    for package, modules in packages.items():
        stub = package.replace('.', '/')
        for fn in glob('../%s/*.py' % stub) + glob('../%s/*.so' % stub):
            module = fn.split('/')[-1][:-3]
            if module == '__init__':
                continue
            modules.append(module)

    return packages


def get_first_docline(module):
    m = importlib.import_module(module)
    if m.__doc__ is not None:
        lines = m.__doc__.split('\n')
        if len(lines) > 0:
            return lines[0]
    return 'FIXME! Write module docstring.'


def underline(line, char, f):
    print(line, file=f)
    print(char*len(line), file=f)
    print(file=f)


def main():
    packages = discover()

    # Write new/updated rst files if needed
    fns_rst = []
    for package, modules in sorted(packages.items()):
        print(package, modules)
        # write the new file to a StringIO
        f = StringIO()
        print('..', file=f)
        print('    This file is automatically generated. Do not make ', file=f)
        print('    changes as these will be overwritten. Rather edit ', file=f)
        print('    the docstrings in the source code.', file=f)
        print(file=f)
        underline('``%s`` -- %s' % (package, get_first_docline(package)), '#', f)
        print(file=f)

        for module in sorted(modules):
            full = package + '.' + module
            print('.. _seclab_rg_%s_%s:', file=f)
            print(file=f)
            underline('``%s`` -- %s' % (full, get_first_docline(full)), '=', f)
            print('.. automodule::', full, file=f)
            print('    :members:', file=f)
            print(file=f)
            print(file=f)

        # write if the contents have changed
        fn_rst = 'rg_%s.rst' % package.replace('.', '_')
        fns_rst.append(fn_rst)
        write_if_changed(fn_rst, f.getvalue())
    fns_rst.append('rg_qff.rst')
    fns_rst.append('rg_qffinputei.rst')


    # Remove other rst files
    for fn_rst in glob('rg_*.rst'):
        if fn_rst not in fns_rst:
            print('Removing %s' % fn_rst)
            os.remove(fn_rst)


if __name__ == '__main__':
    main()

